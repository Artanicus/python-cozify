import json, requests

from . import config as c
from . import hub

cloudBase='https://cloud2.cozify.fi/ui/0.2/'

# auth flow based on and storing into config
# email -> OTP -> remoteToken -> hub ip -> hubToken
def authenticate():
    if 'email' not in  c.state['Cloud'] or not  c.state['Cloud']['email']:
         c.state['Cloud']['email'] = _getEmail()
         c.stateWrite()
    email = c.state['Cloud']['email']

    if _needRemoteToken():
        if _requestlogin(email):
            otp = _getotp()
            remoteToken = _emaillogin(email, otp)
            if remoteToken is not None:
                c.state['Cloud']['remoteToken'] = remoteToken
                c.stateWrite()
            else:
                # remoteToken fail
                print('OTP authentication has failed.')

                # reset Cloud section to allow retry
                c.state['Cloud'] = {}
                c.stateWrite()

                return False
        else:
            # requestlogin fail
            print('requestlogin failed')
            return False
    else:
        # remoteToken already fine, let's just use it
        remoteToken = c.state['Cloud']['remoteToken']

    if _needHubToken():
        hubIps = _lan_ip()
        hubkeys = _hubkeys(remoteToken)
        if hubIps is not None and hubkeys is not None:
            if not hubIps:
                print('No hub LAN ip returned. Make sure you are on the same public network as the hub')
                return False

            for hubIp in hubIps: # hubIps is returned as a list of all hubs
                hubMap = hub._hub(hubIp)
                if hubMap is not None:
                    hubId = hubMap['hubId']
                    hubName = hubMap['name']
                    if hubId in hubkeys:
                        hubToken = hubkeys[hubId]
                    else:
                        print('The hub "%s" is not linked to the given account: "%s"' % (hubName, c.state['Cloud']['email']))
                        # reset Cloud section to allow retry
                        c.state['Cloud'] = {}
                        c.stateWrite()
                        return False
                    if hubToken:
                        if 'Hubs.' + hubName not in c.state:
                            c.state['Hubs.' + hubName] = {}
                        if 'default' not in c.state['Hubs']:
                            c.state['Hubs']['default'] = hubName

                        c.state['Hubs.' + hubName]['hubToken'] = hubToken
                        c.state['Hubs.' + hubName]['host'] = hubIp
                        c.state['Hubs.' + hubName]['hubId'] = hubId # not really used for anything but doesn't hurt
                        c.stateWrite()
                    else:
                        # hubToken fail
                        print('hubToken failed')
                        return False
                else:
                    # hubmap fail
                    print('hubmap failed')
                    return False
        else:
            # lan_ip/hubkeys fail
            print('lan_ip or hubkeys failed')
            return False
    return True



# check if we currently hold a remoteKey.
# TODO(artanicus): need to do an OPTIONS call to check validity as well
def _needRemoteToken():
    # check if we've got a valid remoteToken
    if 'remoteToken' in c.state['Cloud']:
        if c.state['Cloud']['remoteToken'] is not None:
            return False
    return True

def _needHubToken():
    # this is a complex issue, for now just return a naive if default hub key is there, assume it's good
    if 'default' not in c.state['Hubs'] or 'hubtoken' not in c.state['Hubs.' + c.state['Hubs']['default']]:
        return True
    else:
        return False

def _getotp():
    return input('OTP from your email: ')

def _getEmail():
    return input('Enter your Cozify account email address: ')

# 1:1 implementation of user/requestlogin
# email: cozify account email
# returns success Bool
def _requestlogin(email):
    payload = { 'email': email }
    response = requests.post(cloudBase + 'user/requestlogin', params=payload)
    if response.status_code == 200:
        return True
    else:
        print(response.text)
        return False

# 1:1 implementation of user/emaillogin
# email: cozify account email
# otp: OTP provided by user, generated by requestlogin
# returns remote-key or None on failure
def _emaillogin(email, otp):
    payload = {
            'email': email,
            'password': otp
    }

    response = requests.post(cloudBase + 'user/emaillogin', params=payload)
    if response.status_code == 200:
        return response.text
    else:
        print(response.text)
        return None

# 1:1 implementation of hub/lan_ip
# returns list of hub ip's or None
# Oddly enough remoteToken isn't needed here and on the flipside doesn't help.
# By testing it seems hub/lan_ip will use the source ip of the request to determine the validity of the request.
# Thus, only if you're making the request from the same public ip (or ip block?) will this call succeed with useful results
def _lan_ip():
    response = requests.get(cloudBase + 'hub/lan_ip')
    if response.status_code == 200:
        return json.loads(response.text)
    else:
        print(response.text)
        return None

# 1:1 implementation of user/hubkeys
# remoteToken: cozify Cloud remoteToken
# returns map of hubs: { hubId: hubToken }
def _hubkeys(remoteToken):
    headers = {
            'Authorization': remoteToken
    }

    response = requests.get(cloudBase + 'user/hubkeys', headers=headers)
    if response.status_code == 200:
        return json.loads(response.text)
    else:
        print(response.text)
        return None
